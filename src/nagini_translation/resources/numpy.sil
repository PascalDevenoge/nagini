domain Nat {
    function zero(): Nat
    function S(n: Nat): Nat
    function fromInt(i: Int): Nat

    axiom zero {
      fromInt(0) == zero()
    }

    axiom positive {
      forall i: Int :: {fromInt(i)}
        i > 0 ==> fromInt(i) == S(fromInt(i - 1))
    }
}

domain _NumpyHelper {
  function __realIndexLen(n: Nat, idx: Seq[Ref], newAxisObj: Ref): Int
  function __matchIndex(n: Nat, idx: Seq[Ref], shapeLen: Int, nextIdx: Int, newAxisObj: Ref): Seq[Int]
  function __validIndex(n: Nat, shape: Seq[Int], idx: Seq[Ref], minIndices: Seq[Int], maxIndices: Seq[Int], newAxisObj: Ref): Bool
  function __indexedShape(n: Nat, shape: Seq[Int], idx: Seq[Ref], minIndices: Seq[Int], maxIndices: Seq[Int], newAxisObj: Ref): Seq[Int]
  function __max(a: Int, b: Int): Int
  function __min(a: Int, b: Int): Int
  function __endSeq(len: Nat): Seq[Int]
  function __seqProduct(n: Nat, s: Seq[Int]): Int

  axiom realIndexLen {
    forall n: Nat, idx: Seq[Ref], newAxisObj: Ref :: {__realIndexLen(S(n), idx, newAxisObj)}
      __realIndexLen(S(n), idx, newAxisObj) == __realIndexLen(n, idx[1..], newAxisObj) + (idx[0] != newAxisObj ? 1 : 0)
  }

  axiom baseRealIndexLen {
    forall n: Nat, idx: Seq[Ref], newAxisObj: Ref :: {__realIndexLen(n, idx, newAxisObj)}
      (|idx| == 0) ==> (__realIndexLen(n, idx, newAxisObj) == 0)
  }

  axiom matchIndex {
    forall n: Nat, idx: Seq[Ref], shapeLen: Int, nextIdx: Int, newAxisObj: Ref :: {__matchIndex(S(n), idx, shapeLen, nextIdx, newAxisObj)}
      ((issubtype(typeof(idx[0]), int()) || issubtype(typeof(idx[0]), slice())) ==> (__matchIndex(S(n), idx, shapeLen, nextIdx, newAxisObj) == Seq(nextIdx) ++ __matchIndex(n, idx[1..], shapeLen, nextIdx + 1, newAxisObj))) &&
      ((idx[0] == newAxisObj) ==> (__matchIndex(S(n), idx, shapeLen, nextIdx, newAxisObj) == Seq(0) ++ __matchIndex(n, idx[1..], shapeLen, nextIdx, newAxisObj)))
  }

  axiom baseMatchIndex {
    forall n: Nat, idx: Seq[Ref], shapeLen: Int, nextIdx: Int, newAxisObj: Ref :: {__matchIndex(n, idx, shapeLen, nextIdx, newAxisObj)}
      ((|idx| == 0) ==> (__matchIndex(n, idx, shapeLen, nextIdx, newAxisObj) == Seq[Int]()))
  }

  axiom boundsMatchIndex {
    forall i: Int, n: Nat, idx: Seq[Ref], shapeLen: Int, nextIdx: Int, newAxisObj: Ref :: {__matchIndex(n, idx, shapeLen, nextIdx, newAxisObj)[i]}
      ((i >= 0 && i < |__matchIndex(n, idx, shapeLen, nextIdx, newAxisObj)|) ==> (
        __matchIndex(n, idx, shapeLen, nextIdx, newAxisObj)[i] >= 0 &&
        __matchIndex(n, idx, shapeLen, nextIdx, newAxisObj)[i] < shapeLen
      ))
  }

  axiom lenMatchIndex {
    forall n: Nat, idx: Seq[Ref], shapeLen: Int, nextIdx: Int, newAxisObj: Ref :: {__matchIndex(n, idx, shapeLen, nextIdx, newAxisObj)}
      (|__matchIndex(n, idx, shapeLen, nextIdx, newAxisObj)| == |idx|)
  }

  axiom validIndex {
    forall n: Nat, shape: Seq[Int], idx: Seq[Ref], minIndices: Seq[Int], maxIndices: Seq[Int], newAxisObj: Ref :: {__validIndex(S(n), shape, idx, minIndices, maxIndices, newAxisObj)}
      __validIndex(S(n), shape, idx, minIndices, maxIndices, newAxisObj) == (
        ((issubtype(typeof(idx[0]), int()))   ==> (minIndices[0] >= -shape[0] && maxIndices[0] < shape[0] && __validIndex(n, shape[1..], idx[1..], minIndices[1..], maxIndices[1..], newAxisObj))) &&
        ((issubtype(typeof(idx[0]), slice())) ==> (__validIndex(n, shape[1..], idx[1..], minIndices[1..], maxIndices[1..], newAxisObj))) &&
        ((idx[0] == newAxisObj)               ==> (__validIndex(n, shape, idx[1..], minIndices[1..], maxIndices[1..], newAxisObj)))
      ) 
  }

  axiom baseValidIndex {
    forall n: Nat, shape: Seq[Int], idx: Seq[Ref], minIndices: Seq[Int], maxIndices: Seq[Int], newAxisObj: Ref :: {__validIndex(n, shape, idx, minIndices, maxIndices, newAxisObj)}
      ((|shape| == 0 || |idx| == 0 || |minIndices| == 0 || |maxIndices| == 0) ==> (__validIndex(n, shape, idx, minIndices, maxIndices, newAxisObj) == true))
  }

  axiom indexedShape {
    forall n: Nat, shape: Seq[Int], idx: Seq[Ref], minIndices: Seq[Int], maxIndices: Seq[Int], newAxisObj: Ref :: {__indexedShape(S(n), shape, idx, minIndices, maxIndices, newAxisObj)}
      (
        ((issubtype(typeof(idx[0]), int()))   ==> (__indexedShape(S(n), shape, idx, minIndices, maxIndices, newAxisObj) == __indexedShape(n, shape[1..], idx[1..], minIndices[1..], maxIndices[1..], newAxisObj))) &&
        ((issubtype(typeof(idx[0]), slice())) ==> (__indexedShape(S(n), shape, idx, minIndices, maxIndices, newAxisObj) == 
          (Seq(__min(shape[0], __max(0, maxIndices[0] - minIndices[0]))) ++ __indexedShape(n, shape[1..], idx[1..], minIndices[1..], maxIndices[1..], newAxisObj)))) &&
        ((idx[0] == newAxisObj)               ==> (__indexedShape(S(n), shape, idx, minIndices, maxIndices, newAxisObj) == Seq(1) ++ __indexedShape(n, shape, idx[1..], minIndices[1..], maxIndices[1..], newAxisObj)))
      )
  }

  axiom baseIndexedShape {
    forall n: Nat, shape: Seq[Int], idx: Seq[Ref], minIndices: Seq[Int], maxIndices: Seq[Int], newAxisObj: Ref :: {__indexedShape(n, shape, idx, minIndices, maxIndices, newAxisObj)}
      ((|idx| == 0 && |shape| == 0) ==> (__indexedShape(n, shape, idx, minIndices, maxIndices, newAxisObj) == Seq[Int]())) &&
      ((|idx| == 0 && |shape| != 0) ==> (__indexedShape(n, shape, idx, minIndices, maxIndices, newAxisObj) == shape)) &&
      ((|idx| != 0 && |shape| == 0) ==> (__indexedShape(n, shape, idx, minIndices, maxIndices, newAxisObj) == __endSeq(fromInt(|idx|))))
  }

  axiom max {
    forall i: Int, j: Int :: {__max(i, j)}
      __max(i, j) == ((i > j) ? i : j)
  }

  axiom min {
    forall i: Int, j: Int :: {__min(i, j)}
      __min(i, j) == ((i > j) ? j : i)
  }

  axiom endSeq {
    forall n: Nat :: {__endSeq(S(n))}
      __endSeq(S(n)) == Seq(1) ++ __endSeq(n)
  }

  axiom baseEndSeq {
    __endSeq(zero()) == Seq[Int]()
  }

  axiom seqProduct {
    forall n: Nat, s: Seq[Int] :: {__seqProduct(S(n), s)}
      __seqProduct(S(n), s) == s[0] * __seqProduct(n, s[1..])
  }

  axiom baseSeqProduct {
    forall n: Nat, s: Seq[Int] :: {__seqProduct(n, s)}
      (|s| == 0) ==> (__seqProduct(n, s) == 1)
  }
}

function numRemainingElements(t: Ref, newAxisObj: Ref): Int
  decreases _
  requires !issubtype(typeof(newAxisObj), int()) && !issubtype(typeof(newAxisObj), slice())

  ensures result == __realIndexLen(fromInt(tuple___len__(t)), tuple___sil_seq__(t), newAxisObj)

function validIndex(idx: Ref, shape: Ref, newAxisObj: Ref): Bool
  decreases _
  requires !issubtype(typeof(newAxisObj), int()) && !issubtype(typeof(newAxisObj), slice())
  requires forall i: Int :: ((i >= 0 && i < tuple___len__(shape)) ==> (issubtype(typeof(tuple___getitem__(shape, i)), int())))

  ensures result == __validIndex(
    fromInt(tuple___len__(idx)),
    intSeqUnbox(shape),
    tuple___sil_seq__(idx),
    getMinIndices(tuple___sil_seq__(idx), shape, newAxisObj),
    getMaxIndices(tuple___sil_seq__(idx), shape, newAxisObj),
    newAxisObj
  )

function indexedShape(idx: Ref, shape: Ref, newAxisObj: Ref): Ref
  decreases _
  requires !issubtype(typeof(newAxisObj), int()) && !issubtype(typeof(newAxisObj), slice())
  requires forall i: Int :: ((i >= 0 && i < tuple___len__(shape)) ==> (issubtype(typeof(tuple___getitem__(shape, i)), int())))

  ensures result == PSeq___create__(intSeqBox(__indexedShape(
    fromInt(__max(tuple___len__(idx), tuple___len__(shape))),
    intSeqUnbox(shape),
    tuple___sil_seq__(idx),
    getMinIndices(tuple___sil_seq__(idx), shape, newAxisObj),
    getMaxIndices(tuple___sil_seq__(idx), shape, newAxisObj),
    newAxisObj
  )), int())

function seqProduct(t: Ref): Int
  decreases _
  requires forall i: Int :: ((i >= 0 && i < tuple___len__(t)) ==> (issubtype(typeof(tuple___getitem__(t, i)), int())))

  ensures result == __seqProduct(fromInt(tuple___len__(t)), intSeqUnbox(t))

function getMinIndices(idx: Seq[Ref], shape: Ref, newAxisObj: Ref): Seq[Int]
  decreases _
  requires !issubtype(typeof(newAxisObj), int()) && !issubtype(typeof(newAxisObj), slice())

  ensures |result| == |idx|
  ensures forall i: Int :: {result[i]}
    (i >= 0 && i < |idx|) ==> (
      ((issubtype(typeof(idx[i]), int()))   ==> (result[i] == int___unbox__(idx[i]))) &&
      ((issubtype(typeof(idx[i]), slice())) ==> (result[i] == slice___start__(idx[i], 0))) &&
      ((idx[i] == newAxisObj)               ==> (result[i] == 0))
    )

function getMaxIndices(idx: Seq[Ref], shape: Ref, newAxisObj: Ref): Seq[Int]
  decreases _
  requires !issubtype(typeof(newAxisObj), int()) && !issubtype(typeof(newAxisObj), slice())
  requires forall i: Int :: ((i >= 0 && i < tuple___len__(shape)) ==> (issubtype(typeof(tuple___getitem__(shape, i)), int())))

  ensures |result| == |idx|
  ensures forall i: Int :: {result[i]}
    (i >= 0 && i < |idx|) ==> (
      ((issubtype(typeof(idx[i]), int()))   ==> (result[i] == int___unbox__(idx[i]))) &&
      ((issubtype(typeof(idx[i]), slice())) ==> (result[i] == slice___stop__(idx[i], int___unbox__(tuple___getitem__(shape, __matchIndex(fromInt(|idx|), idx, tuple___len__(shape), 0, newAxisObj)[i]))))) &&
      ((idx[i] == newAxisObj)               ==> (result[i] == 0))
    )

function intSeqUnbox(seq: Ref): Seq[Int]
  decreases _
  requires forall i: Int :: ((i >= 0 && i < tuple___len__(seq)) ==> (issubtype(typeof(tuple___getitem__(seq, i)), int())))

  ensures |result| == tuple___len__(seq)
  ensures forall i: Int :: {result[i]}
    ((i >= 0 && i < tuple___len__(seq)) ==> (result[i] == int___unbox__(tuple___getitem__(seq, i))))

function intSeqBox(seq: Seq[Int]): Seq[Ref]
  decreases _
  ensures |result| == |seq|
  ensures forall i: Int :: {result[i]}
    ((i >= 0 && i < |seq|) ==> (result[i] == __prim__int___box__(seq[i])))