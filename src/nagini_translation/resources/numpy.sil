domain Nat {
    function zero(): Nat
    function S(n: Nat): Nat
    function fromInt(i: Int): Nat

    axiom zero {
      fromInt(0) == zero()
    }

    axiom positive {
      forall i: Int ::
        i > 0 ==> fromInt(i) == S(fromInt(i - 1))
    }
}


domain _NumpyHelper {
  function __seqProduct(n: Nat, s: Seq[Int]): Int
  function __filterSeq(n: Nat, s: Seq[Ref], idx: Seq[Ref], drop: Seq[Ref]): Seq[Ref]

  axiom seqProduct {
    forall n: Nat, s: Seq[Int] :: {__seqProduct(S(n), s)}
      __seqProduct(S(n), s) == s[0] * __seqProduct(n, s[1..])
  }

  axiom emptySeqProduct {
    forall n: Nat, s: Seq[Int] :: {__seqProduct(n, s)}
      |s| == 0 ==> __seqProduct(n, s) == 1 
  }

  axiom filterSeq {
    forall n: Nat, s: Seq[Ref], idx: Seq[Ref], drop: Seq[Ref] :: {__filterSeq(S(n), s, idx, drop)}
      __filterSeq(S(n), s, idx, drop) == (
        idx[0] in drop ?
          __filterSeq(n, s[1..], idx[1..], drop) :
          Seq(s[0]) ++ __filterSeq(n, s[1..], idx[1..], drop)
      )
  }

  axiom baseFilterSeq {
    forall n: Nat, s: Seq[Ref], idx: Seq[Ref], drop: Seq[Ref] :: {__filterSeq(n, s, idx, drop)}
      (|s| == 0 || |idx| == 0) ==> __filterSeq(n, s, idx, drop) == Seq[Ref]()
  }
}

function seqProduct(i: Int, t: Ref): Int
  decreases _
  requires forall id: Int :: id >= 0 && id < tuple___len__(t) ==> issubtype(tuple_arg(typeof(t), id), int())
  ensures result == __seqProduct(fromInt(i), intTupleToSeq(t))

function intTupleToSeq(t: Ref): Seq[Int]
  decreases _
  requires forall id: Int :: id >= 0 && id < tuple___len__(t) ==> issubtype(tuple_arg(typeof(t), id), int())
  ensures |result| == tuple___len__(t)
  ensures forall i: Int :: {result[i]} i >= 0 && i < tuple___len__(t) ==> result[i] == int___unbox__(tuple___getitem__(t, i))

function filterSeq(i: Int, s: Ref, drop: Ref): Ref
  decreases _
  requires forall id: Int :: id >= 0 && id < tuple___len__(drop) ==> issubtype(tuple_arg(typeof(drop), id), int())
  ensures result == PSeq___create__(__filterSeq(fromInt(i), tuple___sil_seq__(s), boxIntSeq([0..i)), tuple___sil_seq__(drop)), int())

function boxIntSeq(s: Seq[Int]): Seq[Ref]
  decreases _
  ensures |result| == |s|
  ensures forall i: Int :: {result[i]} i in [0..|s|) ==> result[i] == __prim__int___box__(s[i])