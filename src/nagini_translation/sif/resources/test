/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

function object___bool__(self: Ref) : Bool
    ensures self == null ==> !result
    // We can't actually say that the result is true if self is not None, because
    // this is not the case for collections.
    ensures self != null ==> (let t == (typeof(self)) in ((!issubtype(t, list(list_arg(t, 0))) &&
                                                           !issubtype(t, set(set_arg(t, 0))) &&
                                                           !issubtype(t, dict(dict_arg(t, 0), dict_arg(t, 1)))) ==> result))

function NoneType___bool__(self: Ref) : Bool
    ensures self == null ==> !result

function object___str__(self: Ref) : Ref
    ensures issubtype(typeof(result), str())

function bool___bool__(self: Bool) : Bool
    ensures result == self

function int___bool__(self: Int) : Bool
    ensures result == (self != 0)

function __prim__int___box__(prim: Int): Ref
    ensures typeof(result) == int()
    ensures int___unbox__(result) == prim
    ensures forall other: Int :: {__prim__int___box__(other)} ((__prim__int___box__(other) == result) <==> (other == prim))

function int___unbox__(box: Ref): Int
    requires issubtype(typeof(box), int())
    ensures !issubtype(typeof(box), bool()) ==> __prim__int___box__(result) == box
    ensures issubtype(typeof(box), bool()) ==> __prim__bool___box__(result != 0) == box

function __prim__bool___box__(prim: Bool): Ref
    ensures typeof(result) == bool()
    ensures bool___unbox__(result) == prim
    ensures int___unbox__(result) == (prim ? 1 : 0)

function bool___unbox__(box: Ref): Bool
    requires issubtype(typeof(box), bool())
    ensures __prim__bool___box__(result) == box

function int___eq__(self: Ref, other: Ref): Bool
    requires issubtype(typeof(self), int())
    requires issubtype(typeof(other), int())
{
    int___unbox__(self) == int___unbox__(other)
}

function bool___eq__(self: Ref, other: Ref): Bool
    requires issubtype(typeof(self), bool())
    requires issubtype(typeof(other), bool())
{
    bool___unbox__(self) == bool___unbox__(other)
}

function int___ge__(self: Int, other: Int): Bool
{
    self >= other
}

function int___gt__(self: Int, other: Int): Bool
{
    self > other
}

function int___le__(self: Int, other: Int): Bool
{
    self <= other
}

function int___lt__(self: Int, other: Int): Bool
{
    self < other
}

function int___add__(self: Int, other: Int): Int
{
    self + other
}

function int___sub__(self: Int, other: Int): Int
{
    self - other
}

function int___mul__(self: Int, other: Int): Int
{
    self * other
}

function int___floordiv__(self: Int, other: Int): Int
    requires other != 0
{
    self \ other
}

function int___div__(self: Int, other: Int): Ref
    requires other != 0
    ensures (self % other == 0) ==> (typeof(result) == int() && int___unbox__(result) == self \ other)
    ensures (self % other != 0) ==> typeof(result) == float()

function int___mod__(self: Int, other: Int): Int
    requires other != 0
{
    self % other
}

function float___create__(i: Int): Ref
    ensures typeof(result) == float()

function float___bool__(self: Ref): Bool
    requires self != null ==> issubtype(typeof(self), float())
    ensures self == null ==> !result
    ensures issubtype(typeof(self), int()) ==> (result == int___bool__(int___unbox__(self)))

function float___ge__(self: Ref, other: Ref): Bool
    requires issubtype(typeof(self), float())
    requires issubtype(typeof(other), float())
    ensures (issubtype(typeof(self), int()) && issubtype(typeof(other), int())) ==>
            (result == int___ge__(int___unbox__(self), int___unbox__(other)))

function float___gt__(self: Ref, other: Ref): Bool
    requires issubtype(typeof(self), float())
    requires issubtype(typeof(other), float())
    ensures (issubtype(typeof(self), int()) && issubtype(typeof(other), int())) ==>
            (result == int___gt__(int___unbox__(self), int___unbox__(other)))

function float___le__(self: Ref, other: Ref): Bool
    requires issubtype(typeof(self), float())
    requires issubtype(typeof(other), float())
    ensures (issubtype(typeof(self), int()) && issubtype(typeof(other), int())) ==>
            (result == int___le__(int___unbox__(self), int___unbox__(other)))

function float___lt__(self: Ref, other: Ref): Bool
    requires issubtype(typeof(self), float())
    requires issubtype(typeof(other), float())
    ensures (issubtype(typeof(self), int()) && issubtype(typeof(other), int())) ==>
            (result == int___lt__(int___unbox__(self), int___unbox__(other)))

function float___eq__(self: Ref, other: Ref): Bool
    requires issubtype(typeof(self), float())
    requires issubtype(typeof(other), float())
    ensures (issubtype(typeof(self), int()) && issubtype(typeof(other), int())) ==>
            (result == int___eq__(self, other))

function float___add__(self: Ref, other: Ref): Ref
    requires issubtype(typeof(self), float())
    requires issubtype(typeof(other), float())
    ensures issubtype(typeof(result), float())
    ensures (issubtype(typeof(self), int()) && issubtype(typeof(other), int())) ==>
            (result == __prim__int___box__(int___add__(int___unbox__(self), int___unbox__(other))))

function float___sub__(self: Ref, other: Ref): Ref
    requires issubtype(typeof(self), float())
    requires issubtype(typeof(other), float())
    ensures issubtype(typeof(result), float())
    ensures (issubtype(typeof(self), int()) && issubtype(typeof(other), int())) ==>
            (result == __prim__int___box__(int___sub__(int___unbox__(self), int___unbox__(other))))

function float___mul__(self: Ref, other: Ref): Ref
    requires issubtype(typeof(self), float())
    requires issubtype(typeof(other), float())
    ensures issubtype(typeof(result), float())
    ensures (issubtype(typeof(self), int()) && issubtype(typeof(other), int())) ==>
            (result == __prim__int___box__(int___mul__(int___unbox__(self), int___unbox__(other))))

function float___div__(self: Ref, other: Ref): Ref
    requires issubtype(typeof(self), float())
    requires issubtype(typeof(other), float())
    requires issubtype(typeof(other), int()) ==> int___unbox__(other) != 0
    requires issubtype(typeof(other), int())  // cannot express non-zero at the moment
    ensures issubtype(typeof(result), float())
    ensures (issubtype(typeof(self), int()) && issubtype(typeof(other), int())) ==>
            (result == int___div__(int___unbox__(self), int___unbox__(other)))

function object___eq__(self: Ref, other: Ref): Bool
    ensures self == other ==> result
    ensures ((self == null) != (other == null)) ==> !result

function Place___eq__(self: Ref, other: Ref): Bool
    ensures result == (self == other)

function object___cast__(typ: PyType, obj: Ref): Ref
    requires issubtype(typeof(obj), typ)
    ensures result == obj
    ensures issubtype(typeof(obj), typ)

function max(a: Ref, b: Ref): Int
    requires issubtype(typeof(a), int()) && issubtype(typeof(b), int())
    ensures result == ((int___unbox__(a) > int___unbox__(b)) ? int___unbox__(a) : int___unbox__(b))

function min(a: Ref, b: Ref): Int
    requires issubtype(typeof(a), int()) && issubtype(typeof(b), int())
    ensures result == ((int___unbox__(a) > int___unbox__(b)) ? int___unbox__(b) : int___unbox__(a))

function abs(a: Int): Int
    ensures result == (a >= 0 ? a : -a)

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

function Level(r: Ref): Perm

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

domain PyType {
    function typeof(r: Ref): PyType
    function issubtype(t1: PyType, t2: PyType):Bool
    function list(t: PyType): PyType
    function list_arg(t: PyType, i: Int): PyType
    function set(t: PyType): PyType
    function set_arg(t: PyType, i: Int): PyType
    function dict(t: PyType, v: PyType): PyType
    function dict_arg(t: PyType, i: Int): PyType
    function tuple(s: Seq[PyType]): PyType
    function tuple_args(t: PyType): Seq[PyType]
    function tuple_arg(t: PyType, i: Int): PyType
    function Iterator(t: PyType): PyType
    function Iterator_arg(t: PyType, i: Int): PyType
    function Sequence(t: PyType): PyType
    function Sequence_arg(t: PyType, i: Int): PyType
    function PSet(t: PyType): PyType
    function PSet_arg(t: PyType, i: Int): PyType

    unique function int(): PyType
    unique function float(): PyType
    unique function bool(): PyType
    unique function bytes(): PyType
    unique function bytearray(): PyType
    unique function range(): PyType
    unique function slice(): PyType
    unique function str(): PyType
    unique function NoneType(): PyType
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

domain Measure$ {

    function Measure$create(guard: Bool, key: Ref, value: Int): Measure$

    function Measure$guard(m: Measure$): Bool

    function Measure$key(m: Measure$): Ref

    function Measure$value(m: Measure$): Int

    axiom Measure$A0 {
        (forall g: Bool, k: Ref, v: Int :: {Measure$guard(Measure$create(g, k, v))} Measure$guard(Measure$create(g, k, v)) == g)
    }

    axiom Measure$A1 {
        (forall g: Bool, k: Ref, v: Int :: {Measure$key(Measure$create(g, k, v))} Measure$key(Measure$create(g, k, v)) == k)
    }

    axiom Measure$A2 {
        (forall g: Bool, k: Ref, v: Int :: {Measure$value(Measure$create(g, k, v))} Measure$value(Measure$create(g, k, v)) == v)
    }
}

function Measure$check(map: Seq[Measure$], key: Ref, value: Int): Bool
{
    (forall m: Measure$ :: {m in map} m in map ==>
     ((Measure$guard(m) && Measure$key(m) == key) ==> Measure$value(m) > value))
}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Domain that contains functions for encoding and combining names (represented as
 * integers). Used for checking definedness of global names.
 */

domain _Name {
    function _combine(n1: _Name, n2: _Name): _Name
    function _single(n: Int): _Name

    function _get_combined_prefix(n: _Name): _Name
    function _get_combined_name(n: _Name): _Name
    function _get_value(n: _Name): Int
    function _is_single(n: _Name): Bool

    axiom all_single_or_combined {
        forall n: _Name :: n == _single(_get_value(n)) || n == _combine(_get_combined_prefix(n), _get_combined_name(n))
    }

    axiom single_is_single {
        forall i: Int :: {_single(i)} _is_single(_single(i))
    }

    axiom combined_is_not_single {
        forall n1: _Name, n2: _Name :: {_combine(n1, n2)} !_is_single(_combine(n1, n2))
    }

    axiom decompose_single {
        forall i: Int :: {_single(i)} _get_value(_single(i)) == i
    }

    axiom decompose_combined_prefix {
        forall n1: _Name, n2: _Name :: {_combine(n1, n2)} _get_combined_prefix(_combine(n1, n2)) == n1
    }

    axiom decompose_combined_name {
        forall n1: _Name, n2: _Name :: {_combine(n1, n2)} _get_combined_name(_combine(n1, n2)) == n2
    }

}

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

domain FuncTriple[T, S ,R] {
	function ft_get1(t: FuncTriple[T, S, R]) : T
	function ft_get2(t: FuncTriple[T, S, R]) : S
	function ft_get3(t: FuncTriple[T, S, R]) : R
	function ft_create(a: T, b: S, c: R) : FuncTriple[T, S, R]

	axiom A1 { forall a: T, b: S, c: R :: ft_get1(ft_create(a, b, c)) == a }
	axiom A2 { forall a: T, b: S, c: R :: ft_get2(ft_create(a, b, c)) == b }
	axiom A3 { forall a: T, b: S, c: R :: ft_get3(ft_create(a, b, c)) == c }
}


/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

field list_acc: Seq[Ref]
field list_acc_p: Seq[Ref]

method list___init__(__tl: Bool) returns (res: Ref, res_p: Ref, __new_tl: Bool)
    ensures acc(res.list_acc) && acc(res.list_acc_p)
    ensures res.list_acc == Seq[Ref]()
    ensures res.list_acc_p == Seq[Ref]()
    ensures typeof(res) == list(list_arg(typeof(res), 0))
    ensures res == res_p
    ensures !__tl ==> !__new_tl
{
    assume false
}

method list___setitem__(self: Ref, self_p: Ref,
                        key: Int, key_p: Int,
                        item: Ref, item_p: Ref,
                        __tl: Bool) returns (__new_tl: Bool)
    requires acc(self.list_acc) && acc(self_p.list_acc_p)
    requires key >= 0 && key_p >= 0
    requires key < |self.list_acc| && key_p < |self_p.list_acc_p|
    requires issubtype(typeof(self), list(list_arg(typeof(self), 0)))
    requires issubtype(typeof(self_p), list(list_arg(typeof(self_p), 0)))
    requires issubtype(typeof(item), list_arg(typeof(self), 0))
    requires issubtype(typeof(item_p), list_arg(typeof(self_p), 0))
    ensures acc(self.list_acc) && acc(self_p.list_acc_p)
    ensures self.list_acc == old(self.list_acc)[key := item]
    ensures self_p.list_acc_p == old(self_p.list_acc_p)[key_p := item_p]
    ensures !__tl ==> !__new_tl
{
    assume false
}

function list___getitem__(self: Ref, self_p: Ref,
                          key: Ref, key_p: Ref,
                          __tl: Bool): FuncTriple[Ref, Ref, Bool]
    requires acc(self.list_acc, wildcard) && acc(self_p.list_acc_p, wildcard)
    requires issubtype(typeof(key), int()) && issubtype(typeof(key_p), int())
    requires int___unbox__(key) >= 0 && int___unbox__(key_p) >= 0
    requires int___unbox__(key) < |self.list_acc| && int___unbox__(key_p) < |self_p.list_acc_p|
    requires issubtype(typeof(self), list(list_arg(typeof(self), 0)))
    requires issubtype(typeof(self_p), list(list_arg(typeof(self_p), 0)))
    ensures ft_get1(result) == self.list_acc[int___unbox__(key)]
    ensures ft_get2(result) == self_p.list_acc_p[int___unbox__(key_p)]
    ensures !__tl ==> !ft_get3(result)
    ensures issubtype(typeof(ft_get1(result)), list_arg(typeof(self), 0))
    ensures issubtype(typeof(ft_get2(result)), list_arg(typeof(self_p), 0))

function list___contains__(self: Ref, self_p: Ref, item: Ref, item_p: Ref,
                           __tl: Bool): FuncTriple[Bool, Bool, Bool]
    requires acc(self.list_acc, wildcard) && acc(self_p.list_acc_p, wildcard)
    requires issubtype(typeof(self), list(list_arg(typeof(self), 0)))
    requires issubtype(typeof(self_p), list(list_arg(typeof(self_p), 0)))
    ensures ft_get1(result) == (item in self.list_acc)
    ensures ft_get2(result) == (item_p in self_p.list_acc_p)
    ensures !__tl ==> !ft_get3(result)

function list___len__(self: Ref, self_p: Ref, __tl: Bool) : FuncTriple[Int, Int, Bool]
    requires issubtype(typeof(self), list(list_arg(typeof(self), 0)))
    requires issubtype(typeof(self_p), list(list_arg(typeof(self_p), 0)))
    requires acc(self.list_acc, wildcard) && acc(self_p.list_acc_p, wildcard)
    ensures ft_get1(result) == |self.list_acc| && ft_get2(result) == |self_p.list_acc_p|
    ensures !__tl ==> !ft_get3(result)

method list_append(self: Ref, self_p: Ref,
                   item: Ref, item_p: Ref,
                   __tl: Bool) returns (__new_tl: Bool)
    requires acc(self.list_acc) && acc(self_p.list_acc_p)
    requires issubtype(typeof(self), list(list_arg(typeof(self), 0)))
    requires issubtype(typeof(self_p), list(list_arg(typeof(self_p), 0)))
    requires issubtype(typeof(item), list_arg(typeof(self), 0))
    requires issubtype(typeof(item_p), list_arg(typeof(self_p), 0))
    ensures acc(self.list_acc) && acc(self_p.list_acc_p)
    ensures self.list_acc == old(self.list_acc) ++ Seq(item)
    ensures self_p.list_acc_p == old(self_p.list_acc_p) ++ Seq(item_p)
    ensures !__tl ==> !__new_tl
{
    assume false
}